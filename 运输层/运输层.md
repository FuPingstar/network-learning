#### 运输层协议概述

**从通信和信息处理的角度看，运输层向他上面的应用层提供通信服务，属于面向通信部分的最高层，是用户功能中的最低层。**

1. 进程之间的通信

   + IP协议既然能把源主机发送出的分组按照手不中的目的送到目的主机，为什么还需要再设置一个运输层呢？

     + 网络层和应用层的区别

       + 网络层为主机之间提供逻辑通信，运输层为应用进程之间提供端到端的逻辑通信

         ![网络层和运输层的区别](/images/运输层/网络层和运输层的区别.png)

     + 从IP层来说，通信的两端是两个主机。IP的数据报首部明确标志了这两个主机的IP地址。但是，两个主机之间的通信说的还不够清楚，这是因为，进行真正通信的实体是在主机中的进程，是这个主机中的进程和另一个主机中的进程在交换数据（即通信）。因此严格的讲，两个主机进行通信就是两个主机中的应用进程相互通信。IP协议虽然能把分组送到目的主机，但是这个分组还停留在主机的网络层，而没有交付给主机中的应用进程。从运输层的角度看，通信的真正端点并不是主机而是主机中的应用进程，也就是说，端到端的通信是应用进程之间的通信。

     ![运输层](/images/运输层/运输层.webp)

   + 逻辑通信

     + 上图中的两个运输层之间的双向粗箭头写明**运输层提供应用进程间的逻辑通信。**
     + 逻辑通信的意思是运输层之间的通信好像是沿水平方向传递数据。
       + **但事实上这两个运输层之间并没有一条水平方向的物理连接，要传送的数据是沿着图中的虚线方向进行传送的（经过多个层次）。**

   + 复用和分用

     + 为什么要使用多路复用和多路分用？

       + 如果某层的一个协议对应上层的多个协议/实体，则需要复用/分用。
       + 复用：从多个socket接收数据，为每块数据封装上头部信息，生成segment,交给网络层。
       + 分用：传输层依据头部信息将收到的Segment交给正确的Socket，及不同的进程。

       ![复用和分用](/images/运输层/复用和分用.png)

       + 分用如何工作？
         + 主机接收到的IP数据报（datagram）
           + 每个数据报携带源IP地址，目的IP地址
           + 每个数据报携带一个传输层的段（Segment）
           + 每个段携带源端口号和目的端口号 
         + 主机收到报文段之后，传输层协议提供IP地址和端口号信息，将Segment导向相应的Socket

     + 网络层

       + 复用：发送方不同协议的数据都可以封装成IP数据报发送出去。
       + 分用：接收方中的IP层根据IP首部中的协议字段进行分用，把剥去首部后的数据交付给应当接收这些数据的协议。

     + 运输层

       + 复用：发送方不同的应用进程可以使用同一个运输层协议传送数据（需要加上适当的首部）。
       + 分用：指的是接收方的运输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。

2. 运输层的两个主要协议

   **根据应用程序的不同需求，运输层需要有两种不同的运输协议，面向连接的TCP和无连接的UDP**

   1. 运输层向高层用户屏蔽了下面网络核心细节（如网络拓扑、所采用的的路由选择协议等），使应用进程看见的就好像是两个运输层实体之间有一条端到端的逻辑通信信道，当运输层采用面向连接TCP协议时，尽管下面的网络是不可靠的，但是这种逻辑通信信道就相当于一条全双工的可靠信道。当运输层采用无连接的UDP协议时，这种逻辑通信信道是一条不可靠的信道。

   2. 两个主要协议

      + 用户数据报协议UDP（User Datagram Protocol）
      + 传输控制协议TCP（Transmission Control Protocol)
      + 根据OSI的术语，两个对等的运输实体在通信时传送的数据单位叫做运输协议数据单元（TPDU）。但在TCP/IP体系中，则根据所使用的的协议TCP或者UDP，分别称之为TCP报文段，或者UDP用户数据报。

      ![使用tcp和udp的应用](/images/运输层/使用tcp和udp的应用.webp)

3. 运输层的端口

   + 如何标志网络中的一个应用进程？

     + **单个计算机中的进程是用进程标识符（一个不大的整数）来标志的**，但是在因特网环境下，用操作系统委派的这种进程标识符来标志运行在应用层的各种应用进程则是不行的，因为因特网使用的操作系统的种类很多，不同的操作系统又使用不同格式的进程标识符，为了使运行不同操作系统的应用进程能够相互通信，就必须使用统一的方法对TCP/IP的应用进程进行标志。
     + 把一个特定机器上运行的特定进程指明为因特网上通信的最后终点还是不可行的，因为进程的创建和撤销都是动态的，通信的一方几乎无法识别对方机器上的进程。**往往需要目的主机提供的功能来识别终点，而不需要知道具体实现这个功能的进程是哪一个。**
     + **解决这个问题的方法是在运输层使用协议端口号，简称端口（port），这就是说，虽然通信的终点是应用进程，但是我们只需要把传送的报文交到目的主机的一个合适的目的端口。最后交付给目的进程由TCP来完成。**

   + 运输层端口分类：

     + 服务端使用的端口号

       + 熟知端口号（系统端口号）：数值为0~1023，IANA把这些端口号指派给了最重要的一些应用程序，让所由用户都知道。当一些新的应用程序出现后，IANA必须为它指派一个数值的端口号，否则因特网上的其他应用程序就无法和他进行通信。给出一些常用的熟知端口号：

       ![常用熟知端口号](/images/运输层/常用熟知端口号.png)

       + 登记端口号：数值为1024~49151这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。

     + 客户端使用的端口号

       + 数值为49152~65535.由于这类端口号仅在客户进程运行时才动态选择，因此又叫短暂端口号。

     + 查看端口占用相应进程、杀死进程

       + 查看所有进程 ： netstat -ano
       + 查看占用指定端口的进程： netstat -ano|findstr [端口号]
       + 杀死进程 ： 
         + 找到进程号对应的进程名称：tasklist|findstr [进程号]
         + 根据进程名称杀死进程：taskkill /f /t /im [进程名称]

       
