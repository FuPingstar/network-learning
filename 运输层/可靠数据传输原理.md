**TCP发送的报文段是交给IP层发送的，IP层的服务模式是best effort，尽最大努力服务，也就是说，TCP下面提供的网络是不可靠的传输，因此，必须采取适当的措施才能使得两个运输层之间的通信变得可靠**



##### 可靠数据传输的特点：

+ 传输信道不产生差错
+ 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。



##### 可靠数据传输协议基本结构:接口 

![可靠数据传输协议的基本接口](/images/运输层/可靠数据传输协议的基本结构.png)



**下面我们渐进式的设计可靠数据传输协议，利用状态机（Finite State Machine FSM）刻画可靠传输协议**

有限状态自动机

![有限状态自动机](/images/运输层/有限状态自动机.png)

#### 底层信道可靠

##### RDT1.0

+ 底层信道完全可靠（理想）
  + 不会发生位错误
  + 不会丢弃分组
+ 发送方和接收方（FSM）独立

![RDT1.0](/images/运输层/RDT1.0.png)

#### 产生错误的信道

**如何检测错误？利用校验和检测错误**

**如何从错误中恢复？**

​	确认机制

​		ACK：接收方显示的告知发送方分组已正确接收

​		NAK：接收方显示的告知发送方分组有错误。发送方收到NAK后，重传分组。

​		基于这种重传机制的rdt协议称为ARQ（Automatic Repeat Request）协议



##### RDT2.0(底层信道可能翻转分组中的位)

- 引入的机制
  - 差错检测
  - 接收方反馈控制消息ACK/NAK
  - 重传
- FSM规约

![RDT2.0FSM规约](/images/运输层/RDT2.0FSM规约.png)

- RDT2.0使用场景

  - 无错误场景

  ![RDT2.0无错误场景](/images/运输层/RDT2.0无错误场景.png)

  - 有错误场景

  ![有错误场景](/images/运输层/RDT2.0有错误场景.png)



##### RDT2.1

1. RDT2.0的缺陷

   + 如果ACK/NAK消息发生错误怎么办？
     + 为ACK/NAK增加校验和，检错并纠错
     + 如果ACK/NAK坏掉，发送方重传（不能简单的重传，产生重复分组）
   + 如何解决重复分组的问题？
     + 序列号：发送方给每个分组增加序列号
     + 接收方丢弃重复分组

2. 发送方，应对ACK/NAK破坏

   ![RDT2.1发送方](/images/运输层/RDT2.1发送方.png)

3. 接收方

   1. ![接收方](/images/运输层/RDT2.1接收方.png)

4. RDT2.1与RDT2.0的区别

   + 发送方
     + 每个分组增加了序列号，两个序列号（0 1）就够用
     + 需校验ACK/NAK是否发生错误
     + 状态数量翻倍（必须记住当前分组的序列号）
   + 接收方
     + 需判断分组是否重复（当前状态提供期望收到分组序列号

##### RDT3.0（丢失分组）

+ 如果信道及可能发生错位，也可能发生丢失
  + "校验和+序列号+ACK+重传"机制不再够用
+ 方法：发送方等待合理时间
  + 如果没有收到ACk 重传
  + 如果分组只是延迟而不是丢了
    + 重传会产生重复，序列号机制能够处理
    + 接收方需要在ACK中显示告知所确认的分组
  + 需要定时器
+ RDT3.0发送方FSM规约

![FSM规约](/images/运输层/RDT3.0发送方FSM规约.png)



+ 示例

![RDT3.0示例1](/images/运输层/RDT3.0示例1.png)

![RDT3.0示例2](/images/运输层/RDT3.0示例2.png)







##### 流水线机制

**为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。**

+ 允许发送方在收到ACK之前连续发多个分组，
  + 更大的序列号范围
  + 发送方/接收方需要更大的存储空间缓存分组

![停止等待协议和流水传输协议对比](/images/运输层/停止等待协议和流水传输协议对比.png)



#### 滑动窗口协议（连续ARQ协议）

1. 概念

   + 窗口
     + 允许使用的序列号范围
     + 窗口尺寸为N，最多有N个等待确认的分组
   + 滑动窗口
     + 随着协议的运行，窗口在序列号空间内向前滑动。
   + 滑动窗口协议
     + GBN（Go-Back-N）
     + SR

   **接收方一般采用累积确认的方式，也就是说，接收方不必对收到分组逐个进行确认，而是在收到几个分组之后，对按序到达的最后一个分组进行确认，这样就表示，到这个分组位置的所有分组都已正确收到了。**

2. GBN

   ![GBN](/images/运输层/GBN.png)

   - 原理

     - 分组头部包含k-bit序列号
     - 窗口尺寸为N，最多允许N个分组未确认
     - ACK（n）：确认到序列号n的分组已被正确接收
       - 可能会收到重复分组
     - 超时事件（TimeOut）：重传序列号大于等于N，还未收到ACK的所有分组。

   - 发送方

     ![发送方扩展FSM](/images/运输层/GBN发送方扩展FSM.png)

   - 接收方

     ![接收方扩展FSM](/运输层/GBN接收方扩展FSM.png)

     ACK机制：发送拥有最高序列号的，已被正确接收的分组的ACK

     乱序到达的分组直接丢弃（接收方没有缓存），然后重新确认最大的、按序到达的分组。

     

     GBN示例

     ![GBN示例](/images/运输层/GBN示例.png)

     

     

3. SR（Selective Repeat）

   + 接收方对每个分组单独进行确认
     + 设置缓存机制缓存乱序到达的分组
   + 发送方只是重传没有收到ACK的分组
   + 发送方窗口
   + 接收方窗口

   ![SR接收方传输方窗口](/images/运输层/SR接收方传输方窗口.png)

   





​		![SR协议](/images/运输层/SR协议.png)





















​	

​	